import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class EMACrossStrategy:
    def __init__(self, short_window=20, long_window=50, initial_capital=10000):
        """
        Initialize the EMA Crossover Strategy
        
        Parameters:
        -----------
        short_window : int
            Period for the short EMA
        long_window : int
            Period for the long EMA
        initial_capital : float
            Starting capital for backtesting
        """
        self.short_window = short_window
        self.long_window = long_window
        self.initial_capital = initial_capital
        self.positions = None
        self.portfolio = None
        self.returns = None
        
    def generate_signals(self, data):
        """
        Generate trading signals based on EMA crossover
        
        Parameters:
        -----------
        data : DataFrame
            OHLC data with 'Close' prices
            
        Returns:
        --------
        DataFrame with signals
        """
        # Create a DataFrame to store the signals
        signals = pd.DataFrame(index=data.index)
        signals['price'] = data['Close']
        
        # Calculate the short and long EMAs
        signals['short_ema'] = data['Close'].ewm(span=self.short_window, adjust=False).mean()
        signals['long_ema'] = data['Close'].ewm(span=self.long_window, adjust=False).mean()
        
        # Create a signal when the short EMA crosses the long EMA
        signals['signal'] = 0.0
        
        # When the short EMA crosses above the long EMA, we want to buy (signal = 1)
        # When the short EMA crosses below the long EMA, we want to sell (signal = -1)
        signals['signal'] = np.where(
            signals['short_ema'] > signals['long_ema'], 1.0, 0.0
        )
        
        # Calculate the difference in consecutive signals to detect crossovers
        signals['positions'] = signals['signal'].diff()
        
        return signals
    
    def backtest(self, data):
        """
        Backtest the EMA crossover strategy
        
        Parameters:
        -----------
        data : DataFrame
            OHLC data with 'Close' prices
            
        Returns:
        --------
        DataFrame with backtest results
        """
        # Generate signals
        signals = self.generate_signals(data)
        
        # Initialize the portfolio
        self.positions = pd.DataFrame(index=signals.index).fillna(0.0)
        
        # Buy a 100 shares when signal is 1 (buy)
        self.positions['stock'] = 100 * signals['signal']
        
        # Initialize the portfolio with value owned
        self.portfolio = pd.DataFrame(index=signals.index)
        
        # Calculate the cash owned
        pos_diff = self.positions.diff()
        
        # Add cash to portfolio
        self.portfolio['cash'] = self.initial_capital - (pos_diff['stock'] * signals['price']).cumsum()
        
        # Add holdings to portfolio
        self.portfolio['holdings'] = self.positions['stock'] * signals['price']
        
        # Add total portfolio value
        self.portfolio['total'] = self.portfolio['cash'] + self.portfolio['holdings']
        
        # Calculate returns
        self.returns = self.portfolio['total'].pct_change()
        
        return signals, self.portfolio
    
    def plot_results(self, data, signals):
        """
        Plot the backtest results
        
        Parameters:
        -----------
        data : DataFrame
            OHLC data with 'Close' prices
        signals : DataFrame
            Signals generated by the strategy
        """
        # Create a figure
        fig = plt.figure(figsize=(12, 8))
        
        # Add a subplot and label for y-axis
        ax1 = fig.add_subplot(111, ylabel='Price in $')
        
        # Plot the closing price
        data['Close'].plot(ax=ax1, color='r', lw=2.)
        
        # Plot the short and long EMAs
        signals[['short_ema', 'long_ema']].plot(ax=ax1, lw=2.)
        
        # Plot the buy signals
        ax1.plot(
            signals.loc[signals.positions == 1.0].index,
            signals.short_ema[signals.positions == 1.0],
            '^', markersize=10, color='m'
        )
        
        # Plot the sell signals
        ax1.plot(
            signals.loc[signals.positions == -1.0].index,
            signals.short_ema[signals.positions == -1.0],
            'v', markersize=10, color='k'
        )
        
        # Show the plot
        plt.title('EMA Crossover Strategy')
        plt.xlabel('Date')
        plt.ylabel('Price')
        plt.legend(['Close', 'Short EMA', 'Long EMA', 'Buy', 'Sell'])
        plt.grid(True)
        plt.show()
        
        # Plot portfolio value
        fig = plt.figure(figsize=(12, 4))
        ax2 = fig.add_subplot(111, ylabel='Portfolio value in $')
        self.portfolio['total'].plot(ax=ax2, lw=2.)
        plt.title('Portfolio Value Over Time')
        plt.xlabel('Date')
        plt.ylabel('Portfolio Value')
        plt.grid(True)
        plt.show()
        
    def performance_metrics(self):
        """
        Calculate and return performance metrics
        
        Returns:
        --------
        dict with performance metrics
        """
        if self.returns is None:
            return "Please run backtest first"
            
        # Calculate cumulative returns
        cumulative_return = (self.portfolio['total'].iloc[-1] / self.initial_capital) - 1
        
        # Calculate annualized return
        days = (self.portfolio.index[-1] - self.portfolio.index[0]).days
        annualized_return = (1 + cumulative_return) ** (365 / days) - 1
        
        # Calculate Sharpe ratio (assuming risk-free rate = 0)
        sharpe_ratio = self.returns.mean() / self.returns.std() * np.sqrt(252)
        
        # Calculate max drawdown
        running_max = self.portfolio['total'].cummax()
        drawdown = (self.portfolio['total'] - running_max) / running_max
        max_drawdown = drawdown.min()
        
        return {
            'Cumulative Return': f"{cumulative_return:.2%}",
            'Annualized Return': f"{annualized_return:.2%}",
            'Sharpe Ratio': f"{sharpe_ratio:.2f}",
            'Max Drawdown': f"{max_drawdown:.2%}"
        }

def download_data(ticker, start_date, end_date):
    """
    Download historical data for a ticker
    
    Parameters:
    -----------
    ticker : str
        Stock ticker symbol
    start_date : str
        Start date in 'YYYY-MM-DD' format
    end_date : str
        End date in 'YYYY-MM-DD' format
        
    Returns:
    --------
    DataFrame with OHLC data
    """
    try:
        data = yf.download(ticker, start=start_date, end=end_date)
        return data
    except Exception as e:
        print(f"Error downloading data: {e}")
        return None

def main():
    # Define parameters
    ticker = 'AAPL'  # Example ticker
    start_date = '2020-01-01'
    end_date = '2023-01-01'
    short_window = 20
    long_window = 50
    initial_capital = 10000
    
    # Download data
    print(f"Downloading data for {ticker} from {start_date} to {end_date}...")
    data = download_data(ticker, start_date, end_date)
    
    if data is None:
        print("Failed to download data. Exiting.")
        return
    
    # Initialize and run the strategy
    print("Initializing EMA Crossover Strategy...")
    strategy = EMACrossStrategy(short_window=short_window, long_window=long_window, initial_capital=initial_capital)
    
    print("Running backtest...")
    signals, portfolio = strategy.backtest(data)
    
    # Print performance metrics
    metrics = strategy.performance_metrics()
    print("\nPerformance Metrics:")
    for key, value in metrics.items():
        print(f"{key}: {value}")
    
    # Plot results
    print("\nGenerating plots...")
    strategy.plot_results(data, signals)
    
    # Save results to CSV
    portfolio.to_csv('portfolio_results.csv')
    signals.to_csv('signals.csv')
    print("\nResults saved to CSV files.")

if __name__ == "__main__":
    main()